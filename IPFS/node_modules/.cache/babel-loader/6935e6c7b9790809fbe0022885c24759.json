{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"D:\\\\Mega-AC1982\\\\Develop\\\\Block-Chain\\\\MedicalHistory-BlockChainProject\\\\IPFS\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"D:\\\\Mega-AC1982\\\\Develop\\\\Block-Chain\\\\MedicalHistory-BlockChainProject\\\\IPFS\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/asyncToGenerator\");\n\nconst _require = require('buffer'),\n      Buffer = _require.Buffer;\n\nconst blake = require('blakejs');\n\nconst minB = 0xb201;\nconst minS = 0xb241;\nconst blake2b = {\n  init: blake.blake2bInit,\n  update: blake.blake2bUpdate,\n  digest: blake.blake2bFinal\n};\nconst blake2s = {\n  init: blake.blake2sInit,\n  update: blake.blake2sUpdate,\n  digest: blake.blake2sFinal\n}; // Note that although this function doesn't do any asynchronous work, we mark\n// the function as async because it must return a Promise to match the API\n// for other functions that do perform asynchronous work (see sha.browser.js)\n\nconst makeB2Hash = (size, hf) => /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(data) {\n    var ctx;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          ctx = hf.init(size, null);\n          hf.update(ctx, data);\n          return _context.abrupt(\"return\", Buffer.from(hf.digest(ctx)));\n\n        case 3:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n\n  return function (_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nmodule.exports = table => {\n  for (let i = 0; i < 64; i++) {\n    table[minB + i] = makeB2Hash(i + 1, blake2b);\n  }\n\n  for (let i = 0; i < 32; i++) {\n    table[minS + i] = makeB2Hash(i + 1, blake2s);\n  }\n};","map":{"version":3,"sources":["D:/Mega-AC1982/Develop/Block-Chain/MedicalHistory-BlockChainProject/IPFS/node_modules/ipld-raw/node_modules/multihashing-async/src/blake.js"],"names":["require","Buffer","blake","minB","minS","blake2b","init","blake2bInit","update","blake2bUpdate","digest","blake2bFinal","blake2s","blake2sInit","blake2sUpdate","blake2sFinal","makeB2Hash","size","hf","data","ctx","from","module","exports","table","i"],"mappings":"AAAA;;;;;;iBAEmBA,OAAO,CAAC,QAAD,C;MAAlBC,M,YAAAA,M;;AACR,MAAMC,KAAK,GAAGF,OAAO,CAAC,SAAD,CAArB;;AAEA,MAAMG,IAAI,GAAG,MAAb;AACA,MAAMC,IAAI,GAAG,MAAb;AAEA,MAAMC,OAAO,GAAG;AACdC,EAAAA,IAAI,EAAEJ,KAAK,CAACK,WADE;AAEdC,EAAAA,MAAM,EAAEN,KAAK,CAACO,aAFA;AAGdC,EAAAA,MAAM,EAAER,KAAK,CAACS;AAHA,CAAhB;AAMA,MAAMC,OAAO,GAAG;AACdN,EAAAA,IAAI,EAAEJ,KAAK,CAACW,WADE;AAEdL,EAAAA,MAAM,EAAEN,KAAK,CAACY,aAFA;AAGdJ,EAAAA,MAAM,EAAER,KAAK,CAACa;AAHA,CAAhB,C,CAMA;AACA;AACA;;AACA,MAAMC,UAAU,GAAG,CAACC,IAAD,EAAOC,EAAP;AAAA,sEAAc,iBAAOC,IAAP;AAAA;AAAA;AAAA;AAAA;AACzBC,UAAAA,GADyB,GACnBF,EAAE,CAACZ,IAAH,CAAQW,IAAR,EAAc,IAAd,CADmB;AAE/BC,UAAAA,EAAE,CAACV,MAAH,CAAUY,GAAV,EAAeD,IAAf;AAF+B,2CAGxBlB,MAAM,CAACoB,IAAP,CAAYH,EAAE,CAACR,MAAH,CAAUU,GAAV,CAAZ,CAHwB;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAAd;;AAAA;AAAA;AAAA;AAAA,GAAnB;;AAMAE,MAAM,CAACC,OAAP,GAAkBC,KAAD,IAAW;AAC1B,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,EAApB,EAAwBA,CAAC,EAAzB,EAA6B;AAC3BD,IAAAA,KAAK,CAACrB,IAAI,GAAGsB,CAAR,CAAL,GAAkBT,UAAU,CAACS,CAAC,GAAG,CAAL,EAAQpB,OAAR,CAA5B;AACD;;AACD,OAAK,IAAIoB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,EAApB,EAAwBA,CAAC,EAAzB,EAA6B;AAC3BD,IAAAA,KAAK,CAACpB,IAAI,GAAGqB,CAAR,CAAL,GAAkBT,UAAU,CAACS,CAAC,GAAG,CAAL,EAAQb,OAAR,CAA5B;AACD;AACF,CAPD","sourcesContent":["'use strict'\n\nconst { Buffer } = require('buffer')\nconst blake = require('blakejs')\n\nconst minB = 0xb201\nconst minS = 0xb241\n\nconst blake2b = {\n  init: blake.blake2bInit,\n  update: blake.blake2bUpdate,\n  digest: blake.blake2bFinal\n}\n\nconst blake2s = {\n  init: blake.blake2sInit,\n  update: blake.blake2sUpdate,\n  digest: blake.blake2sFinal\n}\n\n// Note that although this function doesn't do any asynchronous work, we mark\n// the function as async because it must return a Promise to match the API\n// for other functions that do perform asynchronous work (see sha.browser.js)\nconst makeB2Hash = (size, hf) => async (data) => {\n  const ctx = hf.init(size, null)\n  hf.update(ctx, data)\n  return Buffer.from(hf.digest(ctx))\n}\n\nmodule.exports = (table) => {\n  for (let i = 0; i < 64; i++) {\n    table[minB + i] = makeB2Hash(i + 1, blake2b)\n  }\n  for (let i = 0; i < 32; i++) {\n    table[minS + i] = makeB2Hash(i + 1, blake2s)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}