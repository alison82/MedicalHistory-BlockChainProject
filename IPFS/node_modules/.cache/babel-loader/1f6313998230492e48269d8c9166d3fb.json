{"ast":null,"code":"/*\n * Id is an object representation of a peer Id. a peer Id is a multihash\n */\n'use strict';\n\nconst mh = require('multihashes');\n\nconst cryptoKeys = require('libp2p-crypto/src/keys');\n\nconst assert = require('assert');\n\nconst waterfall = require('async/waterfall');\n\nconst withIs = require('class-is');\n\nclass PeerId {\n  constructor(id, privKey, pubKey) {\n    assert(Buffer.isBuffer(id), 'invalid id provided');\n\n    if (privKey && pubKey) {\n      assert(privKey.public.bytes.equals(pubKey.bytes), 'inconsistent arguments');\n    }\n\n    this._id = id;\n    this._idB58String = mh.toB58String(this.id);\n    this._privKey = privKey;\n    this._pubKey = pubKey;\n  }\n\n  get id() {\n    return this._id;\n  }\n\n  set id(val) {\n    throw new Error('Id is immutable');\n  }\n\n  get privKey() {\n    return this._privKey;\n  }\n\n  set privKey(privKey) {\n    this._privKey = privKey;\n  }\n\n  get pubKey() {\n    if (this._pubKey) {\n      return this._pubKey;\n    }\n\n    if (this._privKey) {\n      return this._privKey.public;\n    }\n  }\n\n  set pubKey(pubKey) {\n    this._pubKey = pubKey;\n  } // Return the protobuf version of the public key, matching go ipfs formatting\n\n\n  marshalPubKey() {\n    if (this.pubKey) {\n      return cryptoKeys.marshalPublicKey(this.pubKey);\n    }\n  } // Return the protobuf version of the private key, matching go ipfs formatting\n\n\n  marshalPrivKey() {\n    if (this.privKey) {\n      return cryptoKeys.marshalPrivateKey(this.privKey);\n    }\n  }\n\n  toPrint() {\n    let pid = this.toB58String(); // All sha256 nodes start with Qm\n    // We can skip the Qm to make the peer.ID more useful\n\n    if (pid.startsWith('Qm')) {\n      pid = pid.slice(2);\n    }\n\n    let maxRunes = 6;\n\n    if (pid.length < maxRunes) {\n      maxRunes = pid.length;\n    }\n\n    return '<peer.ID ' + pid.substr(0, maxRunes) + '>';\n  } // return the jsonified version of the key, matching the formatting\n  // of go-ipfs for its config file\n\n\n  toJSON() {\n    return {\n      id: this.toB58String(),\n      privKey: toB64Opt(this.marshalPrivKey()),\n      pubKey: toB64Opt(this.marshalPubKey())\n    };\n  } // encode/decode functions\n\n\n  toHexString() {\n    return mh.toHexString(this.id);\n  }\n\n  toBytes() {\n    return this.id;\n  }\n\n  toB58String() {\n    return this._idB58String;\n  }\n\n  isEqual(id) {\n    if (Buffer.isBuffer(id)) {\n      return this.id.equals(id);\n    } else if (id.id) {\n      return this.id.equals(id.id);\n    } else {\n      throw new Error('not valid Id');\n    }\n  }\n  /*\n   * Check if this PeerId instance is valid (privKey -> pubKey -> Id)\n   */\n\n\n  isValid(callback) {\n    // TODO Needs better checking\n    if (this.privKey && this.privKey.public && this.privKey.public.bytes && Buffer.isBuffer(this.pubKey.bytes) && this.privKey.public.bytes.equals(this.pubKey.bytes)) {\n      callback();\n    } else {\n      callback(new Error('Keys not match'));\n    }\n  }\n\n}\n\nconst PeerIdWithIs = withIs(PeerId, {\n  className: 'PeerId',\n  symbolName: '@libp2p/js-peer-id/PeerId'\n});\nexports = module.exports = PeerIdWithIs;\n\nconst computeDigest = (pubKey, cb) => {\n  if (pubKey.bytes.length <= 42) {\n    const digest = mh.encode(pubKey.bytes, 'identity');\n    cb(null, digest);\n  } else {\n    pubKey.hash((err, digest) => {\n      cb(err, digest);\n    });\n  }\n};\n\nconst computePeerId = (privKey, pubKey, cb) => {\n  computeDigest(pubKey, (err, digest) => {\n    if (err != null) {\n      cb(err);\n    } else {\n      cb(null, new PeerIdWithIs(digest, privKey, pubKey));\n    }\n  });\n}; // generation\n\n\nexports.create = function (opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  opts = opts || {};\n  opts.bits = opts.bits || 2048;\n  opts.keyType = opts.keyType || 'RSA';\n  cryptoKeys.generateKeyPair(opts.keyType, opts.bits, (err, privKey) => {\n    if (err != null) {\n      callback(err);\n    } else {\n      computePeerId(privKey, privKey.public, callback);\n    }\n  });\n};\n\nexports.createFromHexString = function (str) {\n  return new PeerIdWithIs(mh.fromHexString(str));\n};\n\nexports.createFromBytes = function (buf) {\n  return new PeerIdWithIs(buf);\n};\n\nexports.createFromB58String = function (str) {\n  return new PeerIdWithIs(mh.fromB58String(str));\n}; // Public Key input will be a buffer\n\n\nexports.createFromPubKey = function (key, callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('callback is required');\n  }\n\n  let pubKey;\n\n  try {\n    let buf = key;\n\n    if (typeof buf === 'string') {\n      buf = Buffer.from(key, 'base64');\n    }\n\n    if (!Buffer.isBuffer(buf)) throw new Error('Supplied key is neither a base64 string nor a buffer');\n    pubKey = cryptoKeys.unmarshalPublicKey(buf);\n  } catch (err) {\n    return callback(err);\n  }\n\n  computePeerId(null, pubKey, callback);\n}; // Private key input will be a string\n\n\nexports.createFromPrivKey = function (key, callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('callback is required');\n  }\n\n  let buf = key;\n\n  try {\n    if (typeof buf === 'string') {\n      buf = Buffer.from(key, 'base64');\n    }\n\n    if (!Buffer.isBuffer(buf)) throw new Error('Supplied key is neither a base64 string nor a buffer');\n  } catch (err) {\n    return callback(err);\n  }\n\n  cryptoKeys.unmarshalPrivateKey(buf, (err, privKey) => {\n    if (err != null) {\n      callback(err);\n    } else {\n      computePeerId(privKey, privKey.public, callback);\n    }\n  });\n};\n\nexports.createFromJSON = function (obj, callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('callback is required');\n  }\n\n  let id;\n  let rawPrivKey;\n  let rawPubKey;\n  let pub;\n\n  try {\n    id = mh.fromB58String(obj.id);\n    rawPrivKey = obj.privKey && Buffer.from(obj.privKey, 'base64');\n    rawPubKey = obj.pubKey && Buffer.from(obj.pubKey, 'base64');\n    pub = rawPubKey && cryptoKeys.unmarshalPublicKey(rawPubKey);\n  } catch (err) {\n    return callback(err);\n  }\n\n  if (!rawPrivKey) {\n    callback(null, new PeerIdWithIs(id, null, pub));\n    return;\n  }\n\n  waterfall([cb => cryptoKeys.unmarshalPrivateKey(rawPrivKey, cb), (priv, cb) => {\n    computeDigest(priv.public, (err, digest) => {\n      cb(err, digest, priv);\n    });\n  }, (privDigest, priv, cb) => {\n    if (pub) {\n      computeDigest(pub, (err, pubDigest) => {\n        cb(err, privDigest, priv, pubDigest);\n      });\n    } else {\n      cb(null, privDigest, priv);\n    }\n  }], (err, privDigest, priv, pubDigest) => {\n    if (err) {\n      return callback(err);\n    }\n\n    if (pub && !privDigest.equals(pubDigest)) {\n      return callback(new Error('Public and private key do not match'));\n    }\n\n    if (id && !privDigest.equals(id)) {\n      return callback(new Error('Id and private key do not match'));\n    }\n\n    callback(null, new PeerIdWithIs(id, priv, pub));\n  });\n};\n\nexports.isPeerId = function (peerId) {\n  return Boolean(typeof peerId === 'object' && peerId._id && peerId._idB58String);\n};\n\nfunction toB64Opt(val) {\n  if (val) {\n    return val.toString('base64');\n  }\n}","map":{"version":3,"sources":["D:/Mega-AC1982/Develop/Block-Chain/MedicalHistory-BlockChainProject/IPFS/node_modules/ipfs-http-client/node_modules/peer-id/src/index.js"],"names":["mh","require","cryptoKeys","assert","waterfall","withIs","PeerId","constructor","id","privKey","pubKey","Buffer","isBuffer","public","bytes","equals","_id","_idB58String","toB58String","_privKey","_pubKey","val","Error","marshalPubKey","marshalPublicKey","marshalPrivKey","marshalPrivateKey","toPrint","pid","startsWith","slice","maxRunes","length","substr","toJSON","toB64Opt","toHexString","toBytes","isEqual","isValid","callback","PeerIdWithIs","className","symbolName","exports","module","computeDigest","cb","digest","encode","hash","err","computePeerId","create","opts","bits","keyType","generateKeyPair","createFromHexString","str","fromHexString","createFromBytes","buf","createFromB58String","fromB58String","createFromPubKey","key","from","unmarshalPublicKey","createFromPrivKey","unmarshalPrivateKey","createFromJSON","obj","rawPrivKey","rawPubKey","pub","priv","privDigest","pubDigest","isPeerId","peerId","Boolean","toString"],"mappings":"AAAA;;;AAIA;;AAEA,MAAMA,EAAE,GAAGC,OAAO,CAAC,aAAD,CAAlB;;AACA,MAAMC,UAAU,GAAGD,OAAO,CAAC,wBAAD,CAA1B;;AACA,MAAME,MAAM,GAAGF,OAAO,CAAC,QAAD,CAAtB;;AACA,MAAMG,SAAS,GAAGH,OAAO,CAAC,iBAAD,CAAzB;;AACA,MAAMI,MAAM,GAAGJ,OAAO,CAAC,UAAD,CAAtB;;AAEA,MAAMK,MAAN,CAAa;AACXC,EAAAA,WAAW,CAAEC,EAAF,EAAMC,OAAN,EAAeC,MAAf,EAAuB;AAChCP,IAAAA,MAAM,CAACQ,MAAM,CAACC,QAAP,CAAgBJ,EAAhB,CAAD,EAAsB,qBAAtB,CAAN;;AAEA,QAAIC,OAAO,IAAIC,MAAf,EAAuB;AACrBP,MAAAA,MAAM,CAACM,OAAO,CAACI,MAAR,CAAeC,KAAf,CAAqBC,MAArB,CAA4BL,MAAM,CAACI,KAAnC,CAAD,EAA4C,wBAA5C,CAAN;AACD;;AAED,SAAKE,GAAL,GAAWR,EAAX;AACA,SAAKS,YAAL,GAAoBjB,EAAE,CAACkB,WAAH,CAAe,KAAKV,EAApB,CAApB;AACA,SAAKW,QAAL,GAAgBV,OAAhB;AACA,SAAKW,OAAL,GAAeV,MAAf;AACD;;AAED,MAAIF,EAAJ,GAAU;AACR,WAAO,KAAKQ,GAAZ;AACD;;AAED,MAAIR,EAAJ,CAAQa,GAAR,EAAa;AACX,UAAM,IAAIC,KAAJ,CAAU,iBAAV,CAAN;AACD;;AAED,MAAIb,OAAJ,GAAe;AACb,WAAO,KAAKU,QAAZ;AACD;;AAED,MAAIV,OAAJ,CAAaA,OAAb,EAAsB;AACpB,SAAKU,QAAL,GAAgBV,OAAhB;AACD;;AAED,MAAIC,MAAJ,GAAc;AACZ,QAAI,KAAKU,OAAT,EAAkB;AAChB,aAAO,KAAKA,OAAZ;AACD;;AAED,QAAI,KAAKD,QAAT,EAAmB;AACjB,aAAO,KAAKA,QAAL,CAAcN,MAArB;AACD;AACF;;AAED,MAAIH,MAAJ,CAAYA,MAAZ,EAAoB;AAClB,SAAKU,OAAL,GAAeV,MAAf;AACD,GA1CU,CA4CX;;;AACAa,EAAAA,aAAa,GAAI;AACf,QAAI,KAAKb,MAAT,EAAiB;AACf,aAAOR,UAAU,CAACsB,gBAAX,CAA4B,KAAKd,MAAjC,CAAP;AACD;AACF,GAjDU,CAmDX;;;AACAe,EAAAA,cAAc,GAAI;AAChB,QAAI,KAAKhB,OAAT,EAAkB;AAChB,aAAOP,UAAU,CAACwB,iBAAX,CAA6B,KAAKjB,OAAlC,CAAP;AACD;AACF;;AAEDkB,EAAAA,OAAO,GAAI;AACT,QAAIC,GAAG,GAAG,KAAKV,WAAL,EAAV,CADS,CAET;AACA;;AACA,QAAIU,GAAG,CAACC,UAAJ,CAAe,IAAf,CAAJ,EAA0B;AACxBD,MAAAA,GAAG,GAAGA,GAAG,CAACE,KAAJ,CAAU,CAAV,CAAN;AACD;;AACD,QAAIC,QAAQ,GAAG,CAAf;;AACA,QAAIH,GAAG,CAACI,MAAJ,GAAaD,QAAjB,EAA2B;AACzBA,MAAAA,QAAQ,GAAGH,GAAG,CAACI,MAAf;AACD;;AAED,WAAO,cAAcJ,GAAG,CAACK,MAAJ,CAAW,CAAX,EAAcF,QAAd,CAAd,GAAwC,GAA/C;AACD,GAvEU,CAyEX;AACA;;;AACAG,EAAAA,MAAM,GAAI;AACR,WAAO;AACL1B,MAAAA,EAAE,EAAE,KAAKU,WAAL,EADC;AAELT,MAAAA,OAAO,EAAE0B,QAAQ,CAAC,KAAKV,cAAL,EAAD,CAFZ;AAGLf,MAAAA,MAAM,EAAEyB,QAAQ,CAAC,KAAKZ,aAAL,EAAD;AAHX,KAAP;AAKD,GAjFU,CAmFX;;;AACAa,EAAAA,WAAW,GAAI;AACb,WAAOpC,EAAE,CAACoC,WAAH,CAAe,KAAK5B,EAApB,CAAP;AACD;;AAED6B,EAAAA,OAAO,GAAI;AACT,WAAO,KAAK7B,EAAZ;AACD;;AAEDU,EAAAA,WAAW,GAAI;AACb,WAAO,KAAKD,YAAZ;AACD;;AAEDqB,EAAAA,OAAO,CAAE9B,EAAF,EAAM;AACX,QAAIG,MAAM,CAACC,QAAP,CAAgBJ,EAAhB,CAAJ,EAAyB;AACvB,aAAO,KAAKA,EAAL,CAAQO,MAAR,CAAeP,EAAf,CAAP;AACD,KAFD,MAEO,IAAIA,EAAE,CAACA,EAAP,EAAW;AAChB,aAAO,KAAKA,EAAL,CAAQO,MAAR,CAAeP,EAAE,CAACA,EAAlB,CAAP;AACD,KAFM,MAEA;AACL,YAAM,IAAIc,KAAJ,CAAU,cAAV,CAAN;AACD;AACF;AAED;;;;;AAGAiB,EAAAA,OAAO,CAAEC,QAAF,EAAY;AACjB;AACA,QAAI,KAAK/B,OAAL,IACF,KAAKA,OAAL,CAAaI,MADX,IAEF,KAAKJ,OAAL,CAAaI,MAAb,CAAoBC,KAFlB,IAGFH,MAAM,CAACC,QAAP,CAAgB,KAAKF,MAAL,CAAYI,KAA5B,CAHE,IAIF,KAAKL,OAAL,CAAaI,MAAb,CAAoBC,KAApB,CAA0BC,MAA1B,CAAiC,KAAKL,MAAL,CAAYI,KAA7C,CAJF,EAIuD;AACrD0B,MAAAA,QAAQ;AACT,KAND,MAMO;AACLA,MAAAA,QAAQ,CAAC,IAAIlB,KAAJ,CAAU,gBAAV,CAAD,CAAR;AACD;AACF;;AAxHU;;AA2Hb,MAAMmB,YAAY,GAAGpC,MAAM,CAACC,MAAD,EAAS;AAAEoC,EAAAA,SAAS,EAAE,QAAb;AAAuBC,EAAAA,UAAU,EAAE;AAAnC,CAAT,CAA3B;AAEAC,OAAO,GAAGC,MAAM,CAACD,OAAP,GAAiBH,YAA3B;;AAEA,MAAMK,aAAa,GAAG,CAACpC,MAAD,EAASqC,EAAT,KAAgB;AACpC,MAAIrC,MAAM,CAACI,KAAP,CAAakB,MAAb,IAAuB,EAA3B,EAA+B;AAC7B,UAAMgB,MAAM,GAAGhD,EAAE,CAACiD,MAAH,CAAUvC,MAAM,CAACI,KAAjB,EAAwB,UAAxB,CAAf;AACAiC,IAAAA,EAAE,CAAC,IAAD,EAAOC,MAAP,CAAF;AACD,GAHD,MAGO;AACLtC,IAAAA,MAAM,CAACwC,IAAP,CAAY,CAACC,GAAD,EAAMH,MAAN,KAAiB;AAC3BD,MAAAA,EAAE,CAACI,GAAD,EAAMH,MAAN,CAAF;AACD,KAFD;AAGD;AACF,CATD;;AAWA,MAAMI,aAAa,GAAG,CAAC3C,OAAD,EAAUC,MAAV,EAAkBqC,EAAlB,KAAyB;AAC7CD,EAAAA,aAAa,CAACpC,MAAD,EAAS,CAACyC,GAAD,EAAMH,MAAN,KAAiB;AACrC,QAAIG,GAAG,IAAI,IAAX,EAAiB;AACfJ,MAAAA,EAAE,CAACI,GAAD,CAAF;AACD,KAFD,MAEO;AACLJ,MAAAA,EAAE,CAAC,IAAD,EAAO,IAAIN,YAAJ,CAAiBO,MAAjB,EAAyBvC,OAAzB,EAAkCC,MAAlC,CAAP,CAAF;AACD;AACF,GANY,CAAb;AAOD,CARD,C,CAUA;;;AACAkC,OAAO,CAACS,MAAR,GAAiB,UAAUC,IAAV,EAAgBd,QAAhB,EAA0B;AACzC,MAAI,OAAOc,IAAP,KAAgB,UAApB,EAAgC;AAC9Bd,IAAAA,QAAQ,GAAGc,IAAX;AACAA,IAAAA,IAAI,GAAG,EAAP;AACD;;AACDA,EAAAA,IAAI,GAAGA,IAAI,IAAI,EAAf;AACAA,EAAAA,IAAI,CAACC,IAAL,GAAYD,IAAI,CAACC,IAAL,IAAa,IAAzB;AACAD,EAAAA,IAAI,CAACE,OAAL,GAAeF,IAAI,CAACE,OAAL,IAAgB,KAA/B;AAEAtD,EAAAA,UAAU,CAACuD,eAAX,CAA2BH,IAAI,CAACE,OAAhC,EAAyCF,IAAI,CAACC,IAA9C,EAAoD,CAACJ,GAAD,EAAM1C,OAAN,KAAkB;AACpE,QAAI0C,GAAG,IAAI,IAAX,EAAiB;AACfX,MAAAA,QAAQ,CAACW,GAAD,CAAR;AACD,KAFD,MAEO;AACLC,MAAAA,aAAa,CAAC3C,OAAD,EAAUA,OAAO,CAACI,MAAlB,EAA0B2B,QAA1B,CAAb;AACD;AACF,GAND;AAOD,CAhBD;;AAkBAI,OAAO,CAACc,mBAAR,GAA8B,UAAUC,GAAV,EAAe;AAC3C,SAAO,IAAIlB,YAAJ,CAAiBzC,EAAE,CAAC4D,aAAH,CAAiBD,GAAjB,CAAjB,CAAP;AACD,CAFD;;AAIAf,OAAO,CAACiB,eAAR,GAA0B,UAAUC,GAAV,EAAe;AACvC,SAAO,IAAIrB,YAAJ,CAAiBqB,GAAjB,CAAP;AACD,CAFD;;AAIAlB,OAAO,CAACmB,mBAAR,GAA8B,UAAUJ,GAAV,EAAe;AAC3C,SAAO,IAAIlB,YAAJ,CAAiBzC,EAAE,CAACgE,aAAH,CAAiBL,GAAjB,CAAjB,CAAP;AACD,CAFD,C,CAIA;;;AACAf,OAAO,CAACqB,gBAAR,GAA2B,UAAUC,GAAV,EAAe1B,QAAf,EAAyB;AAClD,MAAI,OAAOA,QAAP,KAAoB,UAAxB,EAAoC;AAClC,UAAM,IAAIlB,KAAJ,CAAU,sBAAV,CAAN;AACD;;AAED,MAAIZ,MAAJ;;AAEA,MAAI;AACF,QAAIoD,GAAG,GAAGI,GAAV;;AACA,QAAI,OAAOJ,GAAP,KAAe,QAAnB,EAA6B;AAC3BA,MAAAA,GAAG,GAAGnD,MAAM,CAACwD,IAAP,CAAYD,GAAZ,EAAiB,QAAjB,CAAN;AACD;;AAED,QAAI,CAACvD,MAAM,CAACC,QAAP,CAAgBkD,GAAhB,CAAL,EAA2B,MAAM,IAAIxC,KAAJ,CAAU,sDAAV,CAAN;AAE3BZ,IAAAA,MAAM,GAAGR,UAAU,CAACkE,kBAAX,CAA8BN,GAA9B,CAAT;AACD,GATD,CASE,OAAOX,GAAP,EAAY;AACZ,WAAOX,QAAQ,CAACW,GAAD,CAAf;AACD;;AAEDC,EAAAA,aAAa,CAAC,IAAD,EAAO1C,MAAP,EAAe8B,QAAf,CAAb;AACD,CArBD,C,CAuBA;;;AACAI,OAAO,CAACyB,iBAAR,GAA4B,UAAUH,GAAV,EAAe1B,QAAf,EAAyB;AACnD,MAAI,OAAOA,QAAP,KAAoB,UAAxB,EAAoC;AAClC,UAAM,IAAIlB,KAAJ,CAAU,sBAAV,CAAN;AACD;;AAED,MAAIwC,GAAG,GAAGI,GAAV;;AAEA,MAAI;AACF,QAAI,OAAOJ,GAAP,KAAe,QAAnB,EAA6B;AAC3BA,MAAAA,GAAG,GAAGnD,MAAM,CAACwD,IAAP,CAAYD,GAAZ,EAAiB,QAAjB,CAAN;AACD;;AAED,QAAI,CAACvD,MAAM,CAACC,QAAP,CAAgBkD,GAAhB,CAAL,EAA2B,MAAM,IAAIxC,KAAJ,CAAU,sDAAV,CAAN;AAC5B,GAND,CAME,OAAO6B,GAAP,EAAY;AACZ,WAAOX,QAAQ,CAACW,GAAD,CAAf;AACD;;AAEDjD,EAAAA,UAAU,CAACoE,mBAAX,CAA+BR,GAA/B,EAAoC,CAACX,GAAD,EAAM1C,OAAN,KAAkB;AACpD,QAAI0C,GAAG,IAAI,IAAX,EAAiB;AACfX,MAAAA,QAAQ,CAACW,GAAD,CAAR;AACD,KAFD,MAEO;AACLC,MAAAA,aAAa,CAAC3C,OAAD,EAAUA,OAAO,CAACI,MAAlB,EAA0B2B,QAA1B,CAAb;AACD;AACF,GAND;AAOD,CAxBD;;AA0BAI,OAAO,CAAC2B,cAAR,GAAyB,UAAUC,GAAV,EAAehC,QAAf,EAAyB;AAChD,MAAI,OAAOA,QAAP,KAAoB,UAAxB,EAAoC;AAClC,UAAM,IAAIlB,KAAJ,CAAU,sBAAV,CAAN;AACD;;AAED,MAAId,EAAJ;AACA,MAAIiE,UAAJ;AACA,MAAIC,SAAJ;AACA,MAAIC,GAAJ;;AAEA,MAAI;AACFnE,IAAAA,EAAE,GAAGR,EAAE,CAACgE,aAAH,CAAiBQ,GAAG,CAAChE,EAArB,CAAL;AACAiE,IAAAA,UAAU,GAAGD,GAAG,CAAC/D,OAAJ,IAAeE,MAAM,CAACwD,IAAP,CAAYK,GAAG,CAAC/D,OAAhB,EAAyB,QAAzB,CAA5B;AACAiE,IAAAA,SAAS,GAAGF,GAAG,CAAC9D,MAAJ,IAAcC,MAAM,CAACwD,IAAP,CAAYK,GAAG,CAAC9D,MAAhB,EAAwB,QAAxB,CAA1B;AACAiE,IAAAA,GAAG,GAAGD,SAAS,IAAIxE,UAAU,CAACkE,kBAAX,CAA8BM,SAA9B,CAAnB;AACD,GALD,CAKE,OAAOvB,GAAP,EAAY;AACZ,WAAOX,QAAQ,CAACW,GAAD,CAAf;AACD;;AAED,MAAI,CAACsB,UAAL,EAAiB;AACfjC,IAAAA,QAAQ,CAAC,IAAD,EAAO,IAAIC,YAAJ,CAAiBjC,EAAjB,EAAqB,IAArB,EAA2BmE,GAA3B,CAAP,CAAR;AACA;AACD;;AAEDvE,EAAAA,SAAS,CAAC,CACP2C,EAAD,IAAQ7C,UAAU,CAACoE,mBAAX,CAA+BG,UAA/B,EAA2C1B,EAA3C,CADA,EAER,CAAC6B,IAAD,EAAO7B,EAAP,KAAc;AACZD,IAAAA,aAAa,CAAC8B,IAAI,CAAC/D,MAAN,EAAc,CAACsC,GAAD,EAAMH,MAAN,KAAiB;AAC1CD,MAAAA,EAAE,CAACI,GAAD,EAAMH,MAAN,EAAc4B,IAAd,CAAF;AACD,KAFY,CAAb;AAGD,GANO,EAOR,CAACC,UAAD,EAAaD,IAAb,EAAmB7B,EAAnB,KAA0B;AACxB,QAAI4B,GAAJ,EAAS;AACP7B,MAAAA,aAAa,CAAC6B,GAAD,EAAM,CAACxB,GAAD,EAAM2B,SAAN,KAAoB;AACrC/B,QAAAA,EAAE,CAACI,GAAD,EAAM0B,UAAN,EAAkBD,IAAlB,EAAwBE,SAAxB,CAAF;AACD,OAFY,CAAb;AAGD,KAJD,MAIO;AACL/B,MAAAA,EAAE,CAAC,IAAD,EAAO8B,UAAP,EAAmBD,IAAnB,CAAF;AACD;AACF,GAfO,CAAD,EAgBN,CAACzB,GAAD,EAAM0B,UAAN,EAAkBD,IAAlB,EAAwBE,SAAxB,KAAsC;AACvC,QAAI3B,GAAJ,EAAS;AACP,aAAOX,QAAQ,CAACW,GAAD,CAAf;AACD;;AAED,QAAIwB,GAAG,IAAI,CAACE,UAAU,CAAC9D,MAAX,CAAkB+D,SAAlB,CAAZ,EAA0C;AACxC,aAAOtC,QAAQ,CAAC,IAAIlB,KAAJ,CAAU,qCAAV,CAAD,CAAf;AACD;;AAED,QAAId,EAAE,IAAI,CAACqE,UAAU,CAAC9D,MAAX,CAAkBP,EAAlB,CAAX,EAAkC;AAChC,aAAOgC,QAAQ,CAAC,IAAIlB,KAAJ,CAAU,iCAAV,CAAD,CAAf;AACD;;AAEDkB,IAAAA,QAAQ,CAAC,IAAD,EAAO,IAAIC,YAAJ,CAAiBjC,EAAjB,EAAqBoE,IAArB,EAA2BD,GAA3B,CAAP,CAAR;AACD,GA9BQ,CAAT;AA+BD,CAvDD;;AAyDA/B,OAAO,CAACmC,QAAR,GAAmB,UAAUC,MAAV,EAAkB;AACnC,SAAOC,OAAO,CAAC,OAAOD,MAAP,KAAkB,QAAlB,IACbA,MAAM,CAAChE,GADM,IAEbgE,MAAM,CAAC/D,YAFK,CAAd;AAGD,CAJD;;AAMA,SAASkB,QAAT,CAAmBd,GAAnB,EAAwB;AACtB,MAAIA,GAAJ,EAAS;AACP,WAAOA,GAAG,CAAC6D,QAAJ,CAAa,QAAb,CAAP;AACD;AACF","sourcesContent":["/*\n * Id is an object representation of a peer Id. a peer Id is a multihash\n */\n\n'use strict'\n\nconst mh = require('multihashes')\nconst cryptoKeys = require('libp2p-crypto/src/keys')\nconst assert = require('assert')\nconst waterfall = require('async/waterfall')\nconst withIs = require('class-is')\n\nclass PeerId {\n  constructor (id, privKey, pubKey) {\n    assert(Buffer.isBuffer(id), 'invalid id provided')\n\n    if (privKey && pubKey) {\n      assert(privKey.public.bytes.equals(pubKey.bytes), 'inconsistent arguments')\n    }\n\n    this._id = id\n    this._idB58String = mh.toB58String(this.id)\n    this._privKey = privKey\n    this._pubKey = pubKey\n  }\n\n  get id () {\n    return this._id\n  }\n\n  set id (val) {\n    throw new Error('Id is immutable')\n  }\n\n  get privKey () {\n    return this._privKey\n  }\n\n  set privKey (privKey) {\n    this._privKey = privKey\n  }\n\n  get pubKey () {\n    if (this._pubKey) {\n      return this._pubKey\n    }\n\n    if (this._privKey) {\n      return this._privKey.public\n    }\n  }\n\n  set pubKey (pubKey) {\n    this._pubKey = pubKey\n  }\n\n  // Return the protobuf version of the public key, matching go ipfs formatting\n  marshalPubKey () {\n    if (this.pubKey) {\n      return cryptoKeys.marshalPublicKey(this.pubKey)\n    }\n  }\n\n  // Return the protobuf version of the private key, matching go ipfs formatting\n  marshalPrivKey () {\n    if (this.privKey) {\n      return cryptoKeys.marshalPrivateKey(this.privKey)\n    }\n  }\n\n  toPrint () {\n    let pid = this.toB58String()\n    // All sha256 nodes start with Qm\n    // We can skip the Qm to make the peer.ID more useful\n    if (pid.startsWith('Qm')) {\n      pid = pid.slice(2)\n    }\n    let maxRunes = 6\n    if (pid.length < maxRunes) {\n      maxRunes = pid.length\n    }\n\n    return '<peer.ID ' + pid.substr(0, maxRunes) + '>'\n  }\n\n  // return the jsonified version of the key, matching the formatting\n  // of go-ipfs for its config file\n  toJSON () {\n    return {\n      id: this.toB58String(),\n      privKey: toB64Opt(this.marshalPrivKey()),\n      pubKey: toB64Opt(this.marshalPubKey())\n    }\n  }\n\n  // encode/decode functions\n  toHexString () {\n    return mh.toHexString(this.id)\n  }\n\n  toBytes () {\n    return this.id\n  }\n\n  toB58String () {\n    return this._idB58String\n  }\n\n  isEqual (id) {\n    if (Buffer.isBuffer(id)) {\n      return this.id.equals(id)\n    } else if (id.id) {\n      return this.id.equals(id.id)\n    } else {\n      throw new Error('not valid Id')\n    }\n  }\n\n  /*\n   * Check if this PeerId instance is valid (privKey -> pubKey -> Id)\n   */\n  isValid (callback) {\n    // TODO Needs better checking\n    if (this.privKey &&\n      this.privKey.public &&\n      this.privKey.public.bytes &&\n      Buffer.isBuffer(this.pubKey.bytes) &&\n      this.privKey.public.bytes.equals(this.pubKey.bytes)) {\n      callback()\n    } else {\n      callback(new Error('Keys not match'))\n    }\n  }\n}\n\nconst PeerIdWithIs = withIs(PeerId, { className: 'PeerId', symbolName: '@libp2p/js-peer-id/PeerId' })\n\nexports = module.exports = PeerIdWithIs\n\nconst computeDigest = (pubKey, cb) => {\n  if (pubKey.bytes.length <= 42) {\n    const digest = mh.encode(pubKey.bytes, 'identity')\n    cb(null, digest)\n  } else {\n    pubKey.hash((err, digest) => {\n      cb(err, digest)\n    })\n  }\n}\n\nconst computePeerId = (privKey, pubKey, cb) => {\n  computeDigest(pubKey, (err, digest) => {\n    if (err != null) {\n      cb(err)\n    } else {\n      cb(null, new PeerIdWithIs(digest, privKey, pubKey))\n    }\n  })\n}\n\n// generation\nexports.create = function (opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts\n    opts = {}\n  }\n  opts = opts || {}\n  opts.bits = opts.bits || 2048\n  opts.keyType = opts.keyType || 'RSA'\n\n  cryptoKeys.generateKeyPair(opts.keyType, opts.bits, (err, privKey) => {\n    if (err != null) {\n      callback(err)\n    } else {\n      computePeerId(privKey, privKey.public, callback)\n    }\n  })\n}\n\nexports.createFromHexString = function (str) {\n  return new PeerIdWithIs(mh.fromHexString(str))\n}\n\nexports.createFromBytes = function (buf) {\n  return new PeerIdWithIs(buf)\n}\n\nexports.createFromB58String = function (str) {\n  return new PeerIdWithIs(mh.fromB58String(str))\n}\n\n// Public Key input will be a buffer\nexports.createFromPubKey = function (key, callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('callback is required')\n  }\n\n  let pubKey\n\n  try {\n    let buf = key\n    if (typeof buf === 'string') {\n      buf = Buffer.from(key, 'base64')\n    }\n\n    if (!Buffer.isBuffer(buf)) throw new Error('Supplied key is neither a base64 string nor a buffer')\n\n    pubKey = cryptoKeys.unmarshalPublicKey(buf)\n  } catch (err) {\n    return callback(err)\n  }\n\n  computePeerId(null, pubKey, callback)\n}\n\n// Private key input will be a string\nexports.createFromPrivKey = function (key, callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('callback is required')\n  }\n\n  let buf = key\n\n  try {\n    if (typeof buf === 'string') {\n      buf = Buffer.from(key, 'base64')\n    }\n\n    if (!Buffer.isBuffer(buf)) throw new Error('Supplied key is neither a base64 string nor a buffer')\n  } catch (err) {\n    return callback(err)\n  }\n\n  cryptoKeys.unmarshalPrivateKey(buf, (err, privKey) => {\n    if (err != null) {\n      callback(err)\n    } else {\n      computePeerId(privKey, privKey.public, callback)\n    }\n  })\n}\n\nexports.createFromJSON = function (obj, callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('callback is required')\n  }\n\n  let id\n  let rawPrivKey\n  let rawPubKey\n  let pub\n\n  try {\n    id = mh.fromB58String(obj.id)\n    rawPrivKey = obj.privKey && Buffer.from(obj.privKey, 'base64')\n    rawPubKey = obj.pubKey && Buffer.from(obj.pubKey, 'base64')\n    pub = rawPubKey && cryptoKeys.unmarshalPublicKey(rawPubKey)\n  } catch (err) {\n    return callback(err)\n  }\n\n  if (!rawPrivKey) {\n    callback(null, new PeerIdWithIs(id, null, pub))\n    return\n  }\n\n  waterfall([\n    (cb) => cryptoKeys.unmarshalPrivateKey(rawPrivKey, cb),\n    (priv, cb) => {\n      computeDigest(priv.public, (err, digest) => {\n        cb(err, digest, priv)\n      })\n    },\n    (privDigest, priv, cb) => {\n      if (pub) {\n        computeDigest(pub, (err, pubDigest) => {\n          cb(err, privDigest, priv, pubDigest)\n        })\n      } else {\n        cb(null, privDigest, priv)\n      }\n    }\n  ], (err, privDigest, priv, pubDigest) => {\n    if (err) {\n      return callback(err)\n    }\n\n    if (pub && !privDigest.equals(pubDigest)) {\n      return callback(new Error('Public and private key do not match'))\n    }\n\n    if (id && !privDigest.equals(id)) {\n      return callback(new Error('Id and private key do not match'))\n    }\n\n    callback(null, new PeerIdWithIs(id, priv, pub))\n  })\n}\n\nexports.isPeerId = function (peerId) {\n  return Boolean(typeof peerId === 'object' &&\n    peerId._id &&\n    peerId._idB58String)\n}\n\nfunction toB64Opt (val) {\n  if (val) {\n    return val.toString('base64')\n  }\n}\n"]},"metadata":{},"sourceType":"script"}