{"ast":null,"code":"/**\n * Implementation of the multicodec specification.\n *\n * @module multicodec\n * @example\n * const multicodec = require('multicodec')\n *\n * const prefixedProtobuf = multicodec.addPrefix('protobuf', protobufBuffer)\n * // prefixedProtobuf 0x50...\n *\n */\n'use strict';\n\nconst varint = require('varint');\n\nconst codecNameToCodeVarint = require('./varint-table');\n\nconst codeToCodecName = require('./name-table');\n\nconst util = require('./util');\n\nexports = module.exports;\n/**\n * Prefix a buffer with a multicodec-packed.\n *\n * @param {string|number} multicodecStrOrCode\n * @param {Buffer} data\n * @returns {Buffer}\n */\n\nexports.addPrefix = (multicodecStrOrCode, data) => {\n  let prefix;\n\n  if (Buffer.isBuffer(multicodecStrOrCode)) {\n    prefix = util.varintBufferEncode(multicodecStrOrCode);\n  } else {\n    if (codecNameToCodeVarint[multicodecStrOrCode]) {\n      prefix = codecNameToCodeVarint[multicodecStrOrCode];\n    } else {\n      throw new Error('multicodec not recognized');\n    }\n  }\n\n  return Buffer.concat([prefix, data]);\n};\n/**\n * Decapsulate the multicodec-packed prefix from the data.\n *\n * @param {Buffer} data\n * @returns {Buffer}\n */\n\n\nexports.rmPrefix = data => {\n  varint.decode(data);\n  return data.slice(varint.decode.bytes);\n};\n/**\n * Get the codec of the prefixed data.\n * @param {Buffer} prefixedData\n * @returns {string}\n */\n\n\nexports.getCodec = prefixedData => {\n  const code = util.varintBufferDecode(prefixedData);\n  const codecName = codeToCodecName[code.toString('hex')];\n\n  if (codecName === undefined) {\n    throw new Error('Code `0x' + code.toString('hex') + '` not found');\n  }\n\n  return codecName;\n};\n/**\n * Get the name of the codec.\n * @param {number} codec\n * @returns {string}\n */\n\n\nexports.getName = codec => {\n  return codeToCodecName[codec.toString(16)];\n};\n/**\n * Get the code of the codec\n * @param {string} name\n * @returns {number}\n */\n\n\nexports.getNumber = name => {\n  const code = codecNameToCodeVarint[name];\n\n  if (code === undefined) {\n    throw new Error('Codec `' + name + '` not found');\n  }\n\n  return util.varintBufferDecode(code)[0];\n};\n/**\n * Get the code of the prefixed data.\n * @param {Buffer} prefixedData\n * @returns {number}\n */\n\n\nexports.getCode = prefixedData => {\n  return varint.decode(prefixedData);\n};\n/**\n * Get the code as varint of a codec name.\n * @param {string} codecName\n * @returns {Buffer}\n */\n\n\nexports.getCodeVarint = codecName => {\n  const code = codecNameToCodeVarint[codecName];\n\n  if (code === undefined) {\n    throw new Error('Codec `' + codecName + '` not found');\n  }\n\n  return code;\n};\n/**\n * Get the varint of a code.\n * @param {Number} code\n * @returns {Array.<number>}\n */\n\n\nexports.getVarint = code => {\n  return varint.encode(code);\n}; // Make the constants top-level constants\n\n\nconst constants = require('./constants');\n\nObject.assign(exports, constants); // Human friendly names for printing, e.g. in error messages\n\nexports.print = require('./print');","map":{"version":3,"sources":["D:/Mega-AC1982/Develop/Block-Chain/MedicalHistory-BlockChainProject/IPFS/node_modules/multicodec/src/index.js"],"names":["varint","require","codecNameToCodeVarint","codeToCodecName","util","exports","module","addPrefix","multicodecStrOrCode","data","prefix","Buffer","isBuffer","varintBufferEncode","Error","concat","rmPrefix","decode","slice","bytes","getCodec","prefixedData","code","varintBufferDecode","codecName","toString","undefined","getName","codec","getNumber","name","getCode","getCodeVarint","getVarint","encode","constants","Object","assign","print"],"mappings":"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","sourcesContent":["/**\n * Implementation of the multicodec specification.\n *\n * @module multicodec\n * @example\n * const multicodec = require('multicodec')\n *\n * const prefixedProtobuf = multicodec.addPrefix('protobuf', protobufBuffer)\n * // prefixedProtobuf 0x50...\n *\n */\n'use strict'\n\nconst varint = require('varint')\nconst codecNameToCodeVarint = require('./varint-table')\nconst codeToCodecName = require('./name-table')\nconst util = require('./util')\n\nexports = module.exports\n\n/**\n * Prefix a buffer with a multicodec-packed.\n *\n * @param {string|number} multicodecStrOrCode\n * @param {Buffer} data\n * @returns {Buffer}\n */\nexports.addPrefix = (multicodecStrOrCode, data) => {\n  let prefix\n\n  if (Buffer.isBuffer(multicodecStrOrCode)) {\n    prefix = util.varintBufferEncode(multicodecStrOrCode)\n  } else {\n    if (codecNameToCodeVarint[multicodecStrOrCode]) {\n      prefix = codecNameToCodeVarint[multicodecStrOrCode]\n    } else {\n      throw new Error('multicodec not recognized')\n    }\n  }\n  return Buffer.concat([prefix, data])\n}\n\n/**\n * Decapsulate the multicodec-packed prefix from the data.\n *\n * @param {Buffer} data\n * @returns {Buffer}\n */\nexports.rmPrefix = (data) => {\n  varint.decode(data)\n  return data.slice(varint.decode.bytes)\n}\n\n/**\n * Get the codec of the prefixed data.\n * @param {Buffer} prefixedData\n * @returns {string}\n */\nexports.getCodec = (prefixedData) => {\n  const code = util.varintBufferDecode(prefixedData)\n  const codecName = codeToCodecName[code.toString('hex')]\n  if (codecName === undefined) {\n    throw new Error('Code `0x' + code.toString('hex') + '` not found')\n  }\n  return codecName\n}\n\n/**\n * Get the name of the codec.\n * @param {number} codec\n * @returns {string}\n */\nexports.getName = (codec) => {\n  return codeToCodecName[codec.toString(16)]\n}\n\n/**\n * Get the code of the codec\n * @param {string} name\n * @returns {number}\n */\nexports.getNumber = (name) => {\n  const code = codecNameToCodeVarint[name]\n  if (code === undefined) {\n    throw new Error('Codec `' + name + '` not found')\n  }\n  return util.varintBufferDecode(code)[0]\n}\n\n/**\n * Get the code of the prefixed data.\n * @param {Buffer} prefixedData\n * @returns {number}\n */\nexports.getCode = (prefixedData) => {\n  return varint.decode(prefixedData)\n}\n\n/**\n * Get the code as varint of a codec name.\n * @param {string} codecName\n * @returns {Buffer}\n */\nexports.getCodeVarint = (codecName) => {\n  const code = codecNameToCodeVarint[codecName]\n  if (code === undefined) {\n    throw new Error('Codec `' + codecName + '` not found')\n  }\n  return code\n}\n\n/**\n * Get the varint of a code.\n * @param {Number} code\n * @returns {Array.<number>}\n */\nexports.getVarint = (code) => {\n  return varint.encode(code)\n}\n\n// Make the constants top-level constants\nconst constants = require('./constants')\nObject.assign(exports, constants)\n\n// Human friendly names for printing, e.g. in error messages\nexports.print = require('./print')\n"]},"metadata":{},"sourceType":"script"}