{"ast":null,"code":"/**\n * Multihash implementation in JavaScript.\n *\n * @module multihash\n */\n'use strict';\n\nconst bs58 = require('bs58');\n\nconst cs = require('./constants');\n\nexports.names = cs.names;\nexports.codes = cs.codes;\nexports.defaultLengths = cs.defaultLengths;\n\nconst varint = require('varint');\n/**\n * Convert the given multihash to a hex encoded string.\n *\n * @param {Buffer} hash\n * @returns {string}\n */\n\n\nexports.toHexString = function toHexString(hash) {\n  if (!Buffer.isBuffer(hash)) {\n    throw new Error('must be passed a buffer');\n  }\n\n  return hash.toString('hex');\n};\n/**\n * Convert the given hex encoded string to a multihash.\n *\n * @param {string} hash\n * @returns {Buffer}\n */\n\n\nexports.fromHexString = function fromHexString(hash) {\n  return Buffer.from(hash, 'hex');\n};\n/**\n * Convert the given multihash to a base58 encoded string.\n *\n * @param {Buffer} hash\n * @returns {string}\n */\n\n\nexports.toB58String = function toB58String(hash) {\n  if (!Buffer.isBuffer(hash)) {\n    throw new Error('must be passed a buffer');\n  }\n\n  return bs58.encode(hash);\n};\n/**\n * Convert the given base58 encoded string to a multihash.\n *\n * @param {string|Buffer} hash\n * @returns {Buffer}\n */\n\n\nexports.fromB58String = function fromB58String(hash) {\n  let encoded = hash;\n\n  if (Buffer.isBuffer(hash)) {\n    encoded = hash.toString();\n  }\n\n  return Buffer.from(bs58.decode(encoded));\n};\n/**\n * Decode a hash from the given multihash.\n *\n * @param {Buffer} buf\n * @returns {{code: number, name: string, length: number, digest: Buffer}} result\n */\n\n\nexports.decode = function decode(buf) {\n  if (!Buffer.isBuffer(buf)) {\n    throw new Error('multihash must be a Buffer');\n  }\n\n  if (buf.length < 3) {\n    throw new Error('multihash too short. must be > 3 bytes.');\n  }\n\n  const code = varint.decode(buf);\n\n  if (!exports.isValidCode(code)) {\n    throw new Error(\"multihash unknown function code: 0x\".concat(code.toString(16)));\n  }\n\n  buf = buf.slice(varint.decode.bytes);\n  const len = varint.decode(buf);\n\n  if (len < 1) {\n    throw new Error(\"multihash invalid length: 0x\".concat(len.toString(16)));\n  }\n\n  buf = buf.slice(varint.decode.bytes);\n\n  if (buf.length !== len) {\n    throw new Error(\"multihash length inconsistent: 0x\".concat(buf.toString('hex')));\n  }\n\n  return {\n    code: code,\n    name: cs.codes[code],\n    length: len,\n    digest: buf\n  };\n};\n/**\n *  Encode a hash digest along with the specified function code.\n *\n * > **Note:** the length is derived from the length of the digest itself.\n *\n * @param {Buffer} digest\n * @param {string|number} code\n * @param {number} [length]\n * @returns {Buffer}\n */\n\n\nexports.encode = function encode(digest, code, length) {\n  if (!digest || code === undefined) {\n    throw new Error('multihash encode requires at least two args: digest, code');\n  } // ensure it's a hashfunction code.\n\n\n  const hashfn = exports.coerceCode(code);\n\n  if (!Buffer.isBuffer(digest)) {\n    throw new Error('digest should be a Buffer');\n  }\n\n  if (length == null) {\n    length = digest.length;\n  }\n\n  if (length && digest.length !== length) {\n    throw new Error('digest length should be equal to specified length.');\n  }\n\n  return Buffer.concat([Buffer.from(varint.encode(hashfn)), Buffer.from(varint.encode(length)), digest]);\n};\n/**\n * Converts a hash function name into the matching code.\n * If passed a number it will return the number if it's a valid code.\n * @param {string|number} name\n * @returns {number}\n */\n\n\nexports.coerceCode = function coerceCode(name) {\n  let code = name;\n\n  if (typeof name === 'string') {\n    if (cs.names[name] === undefined) {\n      throw new Error(\"Unrecognized hash function named: \".concat(name));\n    }\n\n    code = cs.names[name];\n  }\n\n  if (typeof code !== 'number') {\n    throw new Error(\"Hash function code should be a number. Got: \".concat(code));\n  }\n\n  if (cs.codes[code] === undefined && !exports.isAppCode(code)) {\n    throw new Error(\"Unrecognized function code: \".concat(code));\n  }\n\n  return code;\n};\n/**\n * Checks wether a code is part of the app range\n *\n * @param {number} code\n * @returns {boolean}\n */\n\n\nexports.isAppCode = function appCode(code) {\n  return code > 0 && code < 0x10;\n};\n/**\n * Checks whether a multihash code is valid.\n *\n * @param {number} code\n * @returns {boolean}\n */\n\n\nexports.isValidCode = function validCode(code) {\n  if (exports.isAppCode(code)) {\n    return true;\n  }\n\n  if (cs.codes[code]) {\n    return true;\n  }\n\n  return false;\n};\n/**\n * Check if the given buffer is a valid multihash. Throws an error if it is not valid.\n *\n * @param {Buffer} multihash\n * @returns {undefined}\n * @throws {Error}\n */\n\n\nfunction validate(multihash) {\n  exports.decode(multihash); // throws if bad.\n}\n\nexports.validate = validate;\n/**\n * Returns a prefix from a valid multihash. Throws an error if it is not valid.\n *\n * @param {Buffer} multihash\n * @returns {undefined}\n * @throws {Error}\n */\n\nexports.prefix = function prefix(multihash) {\n  validate(multihash);\n  return multihash.slice(0, 2);\n};","map":{"version":3,"sources":["D:/Mega-AC1982/Develop/Block-Chain/MedicalHistory-BlockChainProject/IPFS/node_modules/multihashes/src/index.js"],"names":["bs58","require","cs","exports","names","codes","defaultLengths","varint","toHexString","hash","Buffer","isBuffer","Error","toString","fromHexString","from","toB58String","encode","fromB58String","encoded","decode","buf","length","code","isValidCode","slice","bytes","len","name","digest","undefined","hashfn","coerceCode","concat","isAppCode","appCode","validCode","validate","multihash","prefix"],"mappings":"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","sourcesContent":["/**\n * Multihash implementation in JavaScript.\n *\n * @module multihash\n */\n'use strict'\n\nconst bs58 = require('bs58')\n\nconst cs = require('./constants')\n\nexports.names = cs.names\nexports.codes = cs.codes\nexports.defaultLengths = cs.defaultLengths\n\nconst varint = require('varint')\n\n/**\n * Convert the given multihash to a hex encoded string.\n *\n * @param {Buffer} hash\n * @returns {string}\n */\nexports.toHexString = function toHexString (hash) {\n  if (!Buffer.isBuffer(hash)) {\n    throw new Error('must be passed a buffer')\n  }\n\n  return hash.toString('hex')\n}\n\n/**\n * Convert the given hex encoded string to a multihash.\n *\n * @param {string} hash\n * @returns {Buffer}\n */\nexports.fromHexString = function fromHexString (hash) {\n  return Buffer.from(hash, 'hex')\n}\n\n/**\n * Convert the given multihash to a base58 encoded string.\n *\n * @param {Buffer} hash\n * @returns {string}\n */\nexports.toB58String = function toB58String (hash) {\n  if (!Buffer.isBuffer(hash)) {\n    throw new Error('must be passed a buffer')\n  }\n\n  return bs58.encode(hash)\n}\n\n/**\n * Convert the given base58 encoded string to a multihash.\n *\n * @param {string|Buffer} hash\n * @returns {Buffer}\n */\nexports.fromB58String = function fromB58String (hash) {\n  let encoded = hash\n  if (Buffer.isBuffer(hash)) {\n    encoded = hash.toString()\n  }\n\n  return Buffer.from(bs58.decode(encoded))\n}\n\n/**\n * Decode a hash from the given multihash.\n *\n * @param {Buffer} buf\n * @returns {{code: number, name: string, length: number, digest: Buffer}} result\n */\nexports.decode = function decode (buf) {\n  if (!(Buffer.isBuffer(buf))) {\n    throw new Error('multihash must be a Buffer')\n  }\n\n  if (buf.length < 3) {\n    throw new Error('multihash too short. must be > 3 bytes.')\n  }\n\n  const code = varint.decode(buf)\n  if (!exports.isValidCode(code)) {\n    throw new Error(`multihash unknown function code: 0x${code.toString(16)}`)\n  }\n  buf = buf.slice(varint.decode.bytes)\n\n  const len = varint.decode(buf)\n  if (len < 1) {\n    throw new Error(`multihash invalid length: 0x${len.toString(16)}`)\n  }\n  buf = buf.slice(varint.decode.bytes)\n\n  if (buf.length !== len) {\n    throw new Error(`multihash length inconsistent: 0x${buf.toString('hex')}`)\n  }\n\n  return {\n    code: code,\n    name: cs.codes[code],\n    length: len,\n    digest: buf\n  }\n}\n\n/**\n *  Encode a hash digest along with the specified function code.\n *\n * > **Note:** the length is derived from the length of the digest itself.\n *\n * @param {Buffer} digest\n * @param {string|number} code\n * @param {number} [length]\n * @returns {Buffer}\n */\nexports.encode = function encode (digest, code, length) {\n  if (!digest || code === undefined) {\n    throw new Error('multihash encode requires at least two args: digest, code')\n  }\n\n  // ensure it's a hashfunction code.\n  const hashfn = exports.coerceCode(code)\n\n  if (!(Buffer.isBuffer(digest))) {\n    throw new Error('digest should be a Buffer')\n  }\n\n  if (length == null) {\n    length = digest.length\n  }\n\n  if (length && digest.length !== length) {\n    throw new Error('digest length should be equal to specified length.')\n  }\n\n  return Buffer.concat([\n    Buffer.from(varint.encode(hashfn)),\n    Buffer.from(varint.encode(length)),\n    digest\n  ])\n}\n\n/**\n * Converts a hash function name into the matching code.\n * If passed a number it will return the number if it's a valid code.\n * @param {string|number} name\n * @returns {number}\n */\nexports.coerceCode = function coerceCode (name) {\n  let code = name\n\n  if (typeof name === 'string') {\n    if (cs.names[name] === undefined) {\n      throw new Error(`Unrecognized hash function named: ${name}`)\n    }\n    code = cs.names[name]\n  }\n\n  if (typeof code !== 'number') {\n    throw new Error(`Hash function code should be a number. Got: ${code}`)\n  }\n\n  if (cs.codes[code] === undefined && !exports.isAppCode(code)) {\n    throw new Error(`Unrecognized function code: ${code}`)\n  }\n\n  return code\n}\n\n/**\n * Checks wether a code is part of the app range\n *\n * @param {number} code\n * @returns {boolean}\n */\nexports.isAppCode = function appCode (code) {\n  return code > 0 && code < 0x10\n}\n\n/**\n * Checks whether a multihash code is valid.\n *\n * @param {number} code\n * @returns {boolean}\n */\nexports.isValidCode = function validCode (code) {\n  if (exports.isAppCode(code)) {\n    return true\n  }\n\n  if (cs.codes[code]) {\n    return true\n  }\n\n  return false\n}\n\n/**\n * Check if the given buffer is a valid multihash. Throws an error if it is not valid.\n *\n * @param {Buffer} multihash\n * @returns {undefined}\n * @throws {Error}\n */\nfunction validate (multihash) {\n  exports.decode(multihash) // throws if bad.\n}\nexports.validate = validate\n\n/**\n * Returns a prefix from a valid multihash. Throws an error if it is not valid.\n *\n * @param {Buffer} multihash\n * @returns {undefined}\n * @throws {Error}\n */\nexports.prefix = function prefix (multihash) {\n  validate(multihash)\n\n  return multihash.slice(0, 2)\n}\n"]},"metadata":{},"sourceType":"script"}